package com.weavechain.api.sig;

import com.codahale.shamir.Scheme;
import com.weavechain.core.encrypt.KeysProvider;
import org.bouncycastle.jce.ECNamedCurveTable;
import org.bouncycastle.jce.spec.ECParameterSpec;
import org.bouncycastle.math.ec.ECPoint;
import org.bouncycastle.math.ec.custom.sec.SecP256K1Curve;
import org.bouncycastle.util.encoders.Hex;

import java.math.BigDecimal;
import java.math.BigInteger;
import java.security.*;
import java.security.spec.InvalidKeySpecException;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.TreeMap;

public class ThresholdEncSecp {

    private final static boolean USE_SHAMIR = false;

    private final int t;

    private final int n;

    private final Scheme scheme;

    private static final BigInteger ORDER = new SecP256K1Curve().getOrder();

    private static final String CURVE_TYPE = "secp256k1";

    private static final ECParameterSpec CURVE_SPEC = ECNamedCurveTable.getParameterSpec(CURVE_TYPE);

    private static final Object syncObj = new Object();

    private static List<BigInteger> cachedCoef;

    private static int cachedSize;

    public ThresholdEncSecp(int t, int n) {
        this.t = t;
        this.n = n;
        this.scheme = USE_SHAMIR ? new Scheme(SigUtils.random(), n, t) : null;
    }

    public ThresholdEncSecpParams generate() throws NoSuchAlgorithmException, InvalidKeySpecException {
        KeyPair keys = KeysProvider.getInstance().generateKeys();

        BigInteger privateKey = KeysProvider.getBigInt(keys.getPrivate());
        ECPoint publicKey = CURVE_SPEC.getG().multiply(privateKey).normalize();

        List<BigInteger> privateShares = new ArrayList<>();
        List<ECPoint> publicShares = new ArrayList<>();

        List<BigInteger> c = new ArrayList<>();

        c.add(privateKey);
        for (int i = 1; i < t; i++) {
            c.add(new BigInteger(ORDER.bitLength(), SigUtils.random()).add(privateKey).mod(ORDER));
        }

        //private shares generated by a trusted dealer might not be ok
        if (USE_SHAMIR) {
            for (byte[] it : scheme.split(privateKey.toByteArray()).values()) {
                privateShares.add(new BigInteger(it));
            }
        } else {
            for (int j = 1; j <= n; j++) {
                BigInteger sum = BigInteger.ZERO;
                for (int i = 0; i < t; i++) {
                    sum = sum.add(c.get(i).multiply(BigInteger.valueOf(j).pow(i)));
                }
                BigInteger priv = sum.mod(ORDER);
                privateShares.add(priv);
            }
        }


        for (int i = 0; i < t; i++) {
            publicShares.add(CURVE_SPEC.getG().multiply(c.get(i)).normalize());
        }

        return new ThresholdEncSecpParams(
                privateKey,
                new BigInteger(publicKey.getEncoded(true)),
                privateShares,
                publicShares
        );
    }

    public static boolean verify(BigInteger privateShare, int index, List<ECPoint> publicShares) {
        if (USE_SHAMIR) {
            return true;
        }

        if (publicShares.isEmpty()) {
            return false;
        }

        ECPoint check = publicShares.get(0);
        for (int i = 1; i < publicShares.size(); i++) {
            check = check.add(publicShares.get(i).multiply(BigInteger.valueOf(index).pow(i + 1)).normalize());
        }

        ECPoint target = CURVE_SPEC.getG().multiply(privateShare);
        return check.equals(target);
    }

    public BigInteger reconstruct(List<BigInteger> privateShares) {
        if (USE_SHAMIR) {
            Map<Integer, byte[]> parts = new TreeMap<>();
            int i = 1;
            for (BigInteger it : privateShares) {
                parts.put(i++, it.toByteArray());
            }
            return new BigInteger(scheme.join(parts));
        } else {
            BigInteger privateKey = BigInteger.ZERO;
            int size = privateShares.size();
            List<BigInteger> coef = getLagrangeCoef(size);
            for (int i = 1; i <= size; i++) {
                privateKey = privateKey.add(privateShares.get(i - 1).multiply(coef.get(i - 1))).mod(ORDER);
            }
            return privateKey.mod(ORDER);
        }
    }

    public static List<BigInteger> getLagrangeCoef(int size) {
        if (cachedCoef != null && cachedSize >= size) {
            return cachedCoef;
        }

        List<BigInteger> lagrangeCoef = new ArrayList<>();
        for (int i = 1; i <= size; i++) {
            BigDecimal m = BigDecimal.ONE;
            for (int j = 1; j <= size; j++) {
                if (i != j) {
                    m = m.multiply(BigDecimal.valueOf(j * 1.0 / (j - i)));
                }
            }
            lagrangeCoef.add(m.toBigInteger());
        }

        synchronized (syncObj) {
            if (cachedSize < size) {
                cachedCoef = lagrangeCoef;
                cachedSize = size;
            }
        }
        return lagrangeCoef;
    }

    public static String encrypt(BigInteger publicKey, BigInteger value) {
        BigInteger k = new BigInteger(ORDER.bitLength(), SigUtils.random()).mod(ORDER);
        ECPoint P = CURVE_SPEC.getG().multiply(k).normalize();
        ECPoint pub = CURVE_SPEC.getCurve().decodePoint(publicKey.toByteArray());
        ECPoint H = pub.multiply(k).normalize();
        BigInteger enc = value.multiply(H.getYCoord().toBigInteger()).mod(ORDER);

        return Hex.toHexString(P.getEncoded(true)) + " " + Hex.toHexString(enc.toByteArray());
    }

    public static BigInteger decrypt(BigInteger privateKey, String data) {
        String[] it = data.split(" ");
        ECPoint P = CURVE_SPEC.getCurve().decodePoint(Hex.decode(it[0]));
        BigInteger enc = new BigInteger(Hex.decode(it[1]));

        ECPoint H = P.multiply(privateKey).normalize();
        return enc.multiply(H.getYCoord().toBigInteger().modInverse(ORDER)).mod(ORDER);
    }
}